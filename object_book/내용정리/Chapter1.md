Chapter 1

1. 소프트웨어 모듈이 가져야 하는 세가지 기능
   1. 제대로 실행되어야 한다
   2. 변경에 용이해야한다
   3. 이해하기 쉬워야 한다

2. 의존성
   1. 의존성은 변경과 관련되어 있음
   2. 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다
   3. 즉 최소의 의존성으로 연결하는게 중요하다
   4. 의존성이 높다 == 결합도가 높다 

3. 캡슐화
   1. 객체 내부의 세부족인 사항을감추는 것
   2. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것 
   3. 접근 제한을 통해 객체간의 결합도를 낮출 수 있다. 

4. 응집도
   1. 응집도가 높다
      1. 밀접하게 연관된 작업만 수행한다
      2. 연관성 없는 작업은 다른 객체엑 위임한다
      3. 자신의 데이터를 스스로 처리하는 자율적인 객체 

5. 절차적 프로그래밍
   1. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식 
      - theater 의 enter -> 프로세스
      - audience, ticketseller, bag, ticketoffice -> 데이터 
   2. 의존성이 가중된다
      - 변경이 어렵다
      - 변경은 버그를 부른다 

6. 객체지향 프로그래밍
   1. 데이터와 프로세스가 동일한 모듈에 위치

7. 책입의 이동
   1. 객체의 책임을 이동시킴으로서 객체간 의존성을 낮춘다. 
   2. 객체는 객체 자신을 스스로 책임진다. 

8. 상속과 다형성
   1. Movie movie = new AmountDiscountPolicy();
      - movie는 인스턴스 생성시 상속 받은 amountdiscountpolicy, percentdiscountpolicy 둘중 하느를 주입받음
      - 따라서 movie class는 위 두 클래스를 몰라도 생성시점에 주입 받을 수 있다. 

   2. 상속
      1. 기존 클래스가 갖고 있는 모든 속성과 행동을 새로운 클래스에 포함
      2. 컴파일러는 코드 상 부모 클래스가 나오는 모든 장소에서 자식 클래스 사용을 허용함 
      3. 업캐스팅
         - 자식 클래스가 부모클래스를 대신하는 것
      - 구현상속(서브클래싱)
        - 순수하게 코드 재사용이 목적
      - 인터페이스 상속(서브타이핑)
        - 다형적인 협력을 위해 부모 클래스와 자식클래스 공유 

   3. 인터페이스
      1. 객체가 이해할 수 있는 메시지의 목록을 정의
   4. 다형성
      1. 메시지를 수신하는 객체에 따라 달라지는 것 
      2. 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
   5. 지연 바인딩(동적 바인딩)
      - 메시지와 메서드를 실행 시점에 바인딩 한다
   6. 초기 바인딩(정적 바인딩)
      - 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것 

9. 추상화와 유연성
   1. 추상화의 장점
      - 세부적인 내용 무시한 채 상위 정책을 쉽게 표현 가능
      - 추상화를 이용해 상위 정책을 표현하면 구조를 수정하지 않고 새로운 기능을 쉽게 추가, 확장할 수 있다. 

10. 추상 클래스와 인터페이스 트레이드 오프

11. 합성
   - 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용 